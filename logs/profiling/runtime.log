SCRIPT  C:\Users\cgr537\AppData\Local\nvim-data\lazy\oil.nvim\syntax\oil.vim
Sourced 8 times
Total time:   0.000879
 Self time:   0.000879

count  total (s)   self (s)
    8              0.000144 if exists("b:current_syntax")
                              finish
    8              0.000011 endif
                            
    8              0.000136 syn match oilId /^\/\d* / conceal
                            
    8              0.000105 let b:current_syntax = "oil"

SCRIPT  C:\Users\cgr537\AppData\Local\Programs\nvim\share\nvim\runtime\ftplugin\lua.vim
Sourced 1 time
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Phạm Bình An <phambinhanctb2004@gmail.com>
                            " Last Change:		2025 Feb 27
                            
    1              0.000018 if exists("b:did_ftplugin")
                              finish
    1              0.000002 endif
    1              0.000008 let b:did_ftplugin = 1
                            
                            " keep in sync with syntax/lua.vim
    1              0.000004 if !exists("lua_version")
                              " Default is lua 5.3
    1              0.000003   let lua_version = 5
    1              0.000005   let lua_subversion = 3
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000034 setlocal comments=:---,:--
    1              0.000007 setlocal commentstring=--\ %s
    1              0.000009 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000008 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
    1              0.000005 let &l:include = '\<\%(\%(do\|load\)file\|require\)\s*('
    1              0.000010 setlocal includeexpr=s:LuaInclude(v:fname)
    1              0.000005 setlocal suffixesadd=.lua
                            
    1              0.000003 let b:undo_ftplugin = "setl cms< com< def< fo< inc< inex< sua<"
                            
    1              0.000007 if exists("loaded_matchit") && !exists("b:match_words")
    1              0.000003   let b:match_ignorecase = 0
    1              0.000012   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    1              0.000017   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    1              0.000001 endif
                            
    1              0.000021 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    1              0.000001 endif
                            
                            " The rest of the file needs to be :sourced only once per Vim session
    1              0.000004 if exists("s:loaded_lua") || &cp
                              let &cpo = s:cpo_save
                              unlet s:cpo_save
                              finish
    1              0.000001 endif
    1              0.000002 let s:loaded_lua = 1
                            
    1              0.000007 function s:LuaInclude(fname) abort
                              let lua_ver = str2float(printf("%d.%02d", g:lua_version, g:lua_subversion))
                              let fname = tr(a:fname, '.', '/')
                              let paths = lua_ver >= 5.03 ? [fname .. ".lua", fname .. "/init.lua"] : [fname .. ".lua"]
                              for path in paths
                                if filereadable(path)
                                  return path
                                endif
                              endfor
                              return fname
                            endfunction
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  C:\Users\cgr537\AppData\Local\Programs\nvim\share\nvim\runtime\ftplugin\lua.lua
Sourced 1 time
Total time:   0.021598
 Self time:   0.021357

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()
                            
                            vim.bo.includeexpr = [[v:lua.require'vim._ftplugin.lua'.includeexpr(v:fname)]]
                            vim.bo.omnifunc = 'v:lua.vim.lua_omnifunc'
                            vim.wo[0][0].foldexpr = 'v:lua.vim.treesitter.foldexpr()'
                            
                            vim.b.undo_ftplugin = (vim.b.undo_ftplugin or '')
                              .. '\n call v:lua.vim.treesitter.stop()'
                              .. '\n setl omnifunc< foldexpr< includeexpr<'

SCRIPT  C:\Users\cgr537\AppData\Local\Programs\nvim\share\nvim\runtime\indent\lua.vim
Sourced 1 time
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            "		2024 Jul 27: by Vim project: match '(', ')' in function GetLuaIndentIntern()
                            
                            " Only load this indent file when no other was loaded.
    1              0.000011 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000005 let b:did_indent = 1
                            
    1              0.000013 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    1              0.000007 setlocal indentkeys+=0=end,0=until
                            
    1              0.000004 setlocal autoindent
                            
    1              0.000003 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    1              0.000005 if exists("*GetLuaIndent")
                              finish
    1              0.000001 endif
                            
    1              0.000004 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000002 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{', '('
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '\%({\|(\)\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until, '}' and ')'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\|)\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  C:\Users\cgr537\AppData\Local\nvim-data\lazy\nvim-treesitter\autoload\nvim_treesitter.vim
Sourced 1 time
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    1              0.000020 function! nvim_treesitter#statusline(...) abort
                              return luaeval("require'nvim-treesitter.statusline'.statusline(_A)", get(a:, 1, {}))
                            endfunction
                            
    1              0.000003 function! nvim_treesitter#foldexpr() abort
                            	return luaeval(printf('require"nvim-treesitter.fold".get_fold_indic(%d)', v:lnum))
                            endfunction
                            
    1              0.000006 function! nvim_treesitter#installable_parsers(arglead, cmdline, cursorpos) abort
                              return join(luaeval("require'nvim-treesitter.parsers'.available_parsers()") + ['all'], "\n")
                            endfunction
                            
    1              0.000004 function! nvim_treesitter#installed_parsers(arglead, cmdline, cursorpos) abort
                              return join(luaeval("require'nvim-treesitter.info'.installed_parsers()") + ['all'], "\n")
                            endfunction
                            
    1              0.000003 function! nvim_treesitter#available_modules(arglead, cmdline, cursorpos) abort
                              return join(luaeval("require'nvim-treesitter.configs'.available_modules()"), "\n")
                            endfunction
                            
    1              0.000003 function! nvim_treesitter#available_query_groups(arglead, cmdline, cursorpos) abort
                              return join(luaeval("require'nvim-treesitter.query'.available_query_groups()"), "\n")
                            endfunction
                            
    1              0.000003 function! nvim_treesitter#indent() abort
                            	return luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))
                            endfunction

FUNCTION  3()
    Defined: ~\AppData\Local\Programs\nvim\share\nvim\runtime\autoload\provider\clipboard.vim:288
Called 2 times
Total time:   0.038541
 Self time:   0.038541

count  total (s)   self (s)
    2              0.000007   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
    2              0.000001   end
                            
    2              0.000013   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
    2              0.000001   end
                            
    2              0.000004   if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
    2              0.000001   end
                            
    2              0.000008   if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
    2              0.000001   end
    2              0.000023   let s:selections[a:reg] = copy(s:selection)
    2              0.000006   let selection = s:selections[a:reg]
    2              0.000008   let selection.data = [a:lines, a:regtype]
    2              0.000006   let selection.argv = s:copy[a:reg]
    2              0.000005   let selection.detach = s:cache_enabled
    2              0.000004   let selection.cwd = "/"
    2              0.037506   let jobid = jobstart(selection.argv, selection)
    2              0.000031   if jobid > 0
    2              0.000100     call jobsend(jobid, a:lines)
    2              0.000588     call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
    2              0.000032     if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
    2              0.000003     endif
    2              0.000013     let selection.owner = jobid
    2              0.000004     let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
    2              0.000002   endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
    2              0.000010   if exists('prev_job')
                                call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
    2              0.000001   endif
                            
    2              0.000005   return ret

FUNCTION  <SNR>7_Guess()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:38
Called 3 times
Total time:   0.016789
 Self time:   0.016789

count  total (s)   self (s)
    3              0.000049   let has_heredocs = a:detected.filetype =~# '^\%(perl\|php\|ruby\|[cz]\=sh\|bash\)$'
    3              0.000004   let options = {}
    3              0.000018   let heuristics = {'spaces': 0, 'hard': 0, 'soft': 0, 'checked': 0, 'indents': {}}
    3              0.000019   let tabstop = get(a:detected.options, 'tabstop', get(a:detected.defaults, 'tabstop', [8]))[0]
    3              0.000011   let softtab = repeat(' ', tabstop)
    3              0.000004   let waiting_on = ''
    3              0.000005   let prev_indent = -1
    3              0.000004   let prev_line = ''
                            
  160              0.000148   for line in a:lines
  157              0.000253     if len(waiting_on)
                                  if line =~# waiting_on
                                    let waiting_on = ''
                                    let prev_indent = -1
                                    let prev_line = ''
                                  endif
                                  continue
  157              0.000660     elseif line =~# '^\s*$'
   15              0.000011       continue
  142              0.000299     elseif a:detected.filetype ==# 'python' && prev_line[-1:-1] =~# '[[\({]'
                                  let prev_indent = -1
                                  let prev_line = ''
                                  continue
  142              0.000431     elseif line =~# '^=\w' && line !~# '^=\%(end\|cut\)\>'
                                  let waiting_on = '^=\%(end\|cut\)\>'
  142              0.000528     elseif line =~# '^@@\+ -\d\+,\d\+ '
                                  let waiting_on = '^$'
  142              0.000708     elseif line !~# '[/<"`]'
                                  " No need to do other checks
   55              0.000257     elseif line =~# '^\s*/\*' && line !~# '\*/'
                                  let waiting_on = '\*/'
   55              0.000295     elseif line =~# '^\s*<\!--' && line !~# '-->'
                                  let waiting_on = '-->'
   55              0.000525     elseif line =~# '^[^"]*"""'
                                  let waiting_on = '^[^"]*"""'
   55              0.000102     elseif a:detected.filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                  let waiting_on = '^[^`]*`[^`]*$'
   55              0.000049     elseif has_heredocs
                                  let waiting_on = matchstr(line, '<<\s*\([''"]\=\)\zs\w\+\ze\1[^''"`<>]*$')
                                  if len(waiting_on)
                                    let waiting_on = '^' . waiting_on . '$'
                                  endif
  142              0.000064     endif
                            
  142              0.001486     let indent = len(matchstr(substitute(line, '\t', softtab, 'g'), '^ *'))
  142              0.000357     if line =~# '^\t'
                                  let heuristics.hard += 1
  142              0.001772     elseif line =~# '^' . softtab
  110              0.000147       let heuristics.soft += 1
  142              0.000063     endif
  142              0.000462     if line =~# '^  '
  139              0.000177       let heuristics.spaces += 1
  142              0.000060     endif
  142              0.000328     let increment = prev_indent < 0 ? 0 : indent - prev_indent
  142              0.000184     let prev_indent = indent
  142              0.000188     let prev_line = line
  142              0.000264     if increment > 1 && (increment < 4 || increment % 4 == 0)
   31              0.000086       if has_key(heuristics.indents, increment)
   30              0.000063         let heuristics.indents[increment] += 1
    1              0.000001       else
    1              0.000003         let heuristics.indents[increment] = 1
   31              0.000013       endif
   31              0.000050       let heuristics.checked += 1
  142              0.000063     endif
  142              0.000543     if heuristics.checked >= 32 && (heuristics.hard > 3 || heuristics.soft > 3) && get(heuristics.indents, increment) * 2 > heuristics.checked
                                  if heuristics.spaces
                                    break
                                  elseif !exists('no_space_indent')
                                    let no_space_indent = stridx("\n" . join(a:lines, "\n"), "\n  ") < 0
                                    if no_space_indent
                                      break
                                    endif
                                  endif
                                  break
  142              0.000057     endif
  145              0.000117   endfor
                            
    3              0.000016   let a:detected.heuristics[a:source] = heuristics
                            
    3              0.000006   let max_frequency = 0
    4              0.000019   for [shiftwidth, frequency] in items(heuristics.indents)
    1              0.000004     if frequency > max_frequency || frequency == max_frequency && +shiftwidth < get(options, 'shiftwidth')
    1              0.000003       let options.shiftwidth = +shiftwidth
    1              0.000002       let max_frequency = frequency
    1              0.000001     endif
    4              0.000003   endfor
                            
    3              0.000011   if heuristics.hard && !heuristics.spaces && !has_key(a:detected.options, 'tabstop')
                                let options = {'expandtab': 0, 'shiftwidth': 0}
    3              0.000006   elseif heuristics.hard > heuristics.soft
                                let options.expandtab = 0
                                let options.tabstop = tabstop
    3              0.000002   else
    3              0.000004     if heuristics.soft
    1              0.000002       let options.expandtab = 1
    3              0.000002     endif
    3              0.000105     if heuristics.hard || has_key(a:detected.options, 'tabstop') || stridx(join(a:lines, "\n"), "\t") >= 0
                                  let options.tabstop = tabstop
    3              0.000018     elseif !&g:shiftwidth && has_key(options, 'shiftwidth') && !has_key(a:detected.options, 'shiftwidth')
                                  let options.tabstop = options.shiftwidth
                                  let options.shiftwidth = 0
    3              0.000002     endif
    3              0.000002   endif
                            
    3              0.000021   call map(options, '[v:val, a:source]')
    3              0.000122   call extend(a:detected.options, options, 'keep')

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: ~\AppData\Local\Programs\nvim\share\nvim\runtime\ftplugin.vim:15
Called 9 times
Total time:   0.092696
 Self time:   0.070702

count  total (s)   self (s)
    9              0.000094     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    9              0.000012     endif
                            
    9              0.000085     let s = expand("<amatch>")
    9              0.000032     if s != ""
    9              0.000102       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    9              0.000008       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   18              0.000144       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    9   0.091691   0.069697         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   18              0.000210       endfor
    9              0.000014     endif

FUNCTION  <SNR>7_DetectHeuristics()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:513
Called 3 times
Total time:   0.018015
 Self time:   0.001106

count  total (s)   self (s)
    3              0.000007   let detected = a:into
    3              0.000025   let filetype = split(&l:filetype, '\.', 1)[0]
    3              0.000011   if get(detected, 'filetype', '*') ==# filetype
                                return detected
    3              0.000002   endif
    3              0.000007   let detected.filetype = filetype
    3              0.000008   let options = copy(detected.declared)
    3              0.000006   let detected.options = options
    3              0.000005   let detected.heuristics = {}
    3              0.000006   if has_key(detected, 'patterns')
                                call remove(detected, 'patterns')
    3              0.000002   endif
    3   0.000097   0.000029   let detected.defaults = s:UserOptions(filetype, 'defaults')
    3              0.000034   if empty(filetype) || !get(b:, 'sleuth_automatic', 1) || empty(get(b:, 'sleuth_heuristics', get(g:, 'sleuth_' . filetype . '_heuristics', get(g:, 'sleuth_heuristics', 1))))
                                return detected
    3              0.000001   endif
    3   0.000036   0.000020   if s:Ready(detected)
                                return detected
    3              0.000001   endif
                            
    3              0.000048   let lines = getline(1, 1024)
    3   0.016827   0.000037   call s:Guess(detected.bufname, detected, lines)
    3   0.000047   0.000029   if s:Ready(detected)
    1              0.000002     return detected
    2              0.000013   elseif get(options, 'shiftwidth', [4])[0] < 4 && stridx(join(lines, "\n"), "\t") == -1
                                let options.expandtab = [1, detected.bufname]
                                return detected
    2              0.000001   endif
    2              0.000014   let dir = len(detected.path) ? fnamemodify(detected.path, ':h') : ''
    2   0.000536   0.000519   let root = len(detected.root) ? fnamemodify(detected.root, ':h') : dir ==# s:Slash(expand('~')) ? dir : fnamemodify(dir, ':h')
    2              0.000025   if detected.bufname =~# '^\a\a\+:' || root ==# '.' || !isdirectory(root)
    2              0.000004     let dir = ''
    2              0.000001   endif
    2              0.000011   let c = get(b:, 'sleuth_neighbor_limit', get(g:, 'sleuth_neighbor_limit', 8))
    2              0.000007   if c <= 0 || empty(dir)
    2              0.000005     let detected.patterns = []
                              elseif type(get(b:, 'sleuth_globs')) == type([])
                                let detected.patterns = b:sleuth_globs
                              elseif type(get(g:, 'sleuth_' . detected.filetype . '_globs')) == type([])
                                let detected.patterns = get(g:, 'sleuth_' . detected.filetype . '_globs')
                              else
                                let detected.patterns = ['*' . matchstr(detected.bufname, '/\@<!\.[^][{}*?$~\`./]\+$')]
                                if detected.patterns ==# ['*']
                                  let detected.patterns = [matchstr(detected.bufname, '/\zs[^][{}*?$~\`/]\+\ze/\=$')]
                                  let dir = fnamemodify(dir, ':h')
                                  if empty(detected.patterns[0])
                                    let detected.patterns = []
                                  endif
                                endif
    2              0.000001   endif
    2              0.000023   while c > 0 && dir !~# '^$\|^//[^/]*$' && dir !=# fnamemodify(dir, ':h')
                                for pattern in detected.patterns
                                  for neighbor in split(glob(dir.'/'.pattern), "\n")[0:7]
                                    if neighbor !=# detected.path && filereadable(neighbor)
                                      call s:Guess(neighbor, detected, readfile(neighbor, '', 256))
                                      let c -= 1
                                    endif
                                    if s:Ready(detected)
                                      return detected
                                    endif
                                    if c <= 0
                                      break
                                    endif
                                  endfor
                                  if c <= 0
                                    break
                                  endif
                                endfor
                                if len(dir) <= len(root)
                                  break
                                endif
                                let dir = fnamemodify(dir, ':h')
    2              0.000004   endwhile
    2              0.000006   if !has_key(options, 'shiftwidth')
    2              0.000008     let detected.options = copy(detected.declared)
    2              0.000001   endif
    2              0.000003   return detected

FUNCTION  provider#clipboard#Call()
    Defined: ~\AppData\Local\Programs\nvim\share\nvim\runtime\autoload\provider\clipboard.vim:347
Called 2 times
Total time:   0.038693
 Self time:   0.000152

count  total (s)   self (s)
    2              0.000029   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
    2              0.000005   endif
    2              0.000012   let s:here = v:true
    2              0.000004   try
    2   0.038608   0.000067     return call(s:clipboard[a:method],a:args,s:clipboard)
    2              0.000004   finally
    2              0.000008     let s:here = v:false
    2              0.000003   endtry

FUNCTION  <SNR>17_Remove_Matches()
    Defined: ~\AppData\Local\Programs\nvim\share/nvim/runtime/plugin/matchparen.vim:203
Called 93 times
Total time:   0.002464
 Self time:   0.002464

count  total (s)   self (s)
   93              0.000563   if exists('w:paren_hl_on') && w:paren_hl_on
   12              0.000040     while !empty(w:matchparen_ids)
    6              0.000059       silent! call remove(w:matchparen_ids, 0)->matchdelete()
   12              0.000017     endwhile
    6              0.000016     let w:paren_hl_on = 0
   93              0.000068   endif

FUNCTION  1()
    Defined: ~\AppData\Local\Programs\nvim\share\nvim\runtime\autoload\provider\clipboard.vim:22
Called 2 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
    2              0.000094   if self.owner == a:jobid
    2              0.000022     let self.owner = 0
    2              0.000005   endif
                              " Don't print if exit code is >= 128 ( exit is 128+SIGNUM if by signal (e.g. 143 on SIGTERM))
    2              0.000009   if a:data > 0 && a:data < 128
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
    2              0.000002   endif

FUNCTION  <SNR>7_EditorConfigToOptions()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:329
Called 3 times
Total time:   0.000432
 Self time:   0.000432

count  total (s)   self (s)
    3              0.000006   let options = {}
    3              0.000024   let pairs = map(copy(a:pairs), 'v:val[0]')
    3              0.000011   let sources = map(copy(a:pairs), 'v:val[1:-1]')
    3              0.000010   call filter(pairs, 'v:val !=? "unset"')
                            
    3              0.000009   if get(pairs, 'indent_style', '') ==? 'tab'
                                let options.expandtab = [0] + sources.indent_style
    3              0.000009   elseif get(pairs, 'indent_style', '') ==? 'space'
                                let options.expandtab = [1] + sources.indent_style
    3              0.000002   endif
                            
    3              0.000034   if get(pairs, 'indent_size', '') =~? '^[1-9]\d*$\|^tab$'
                                let options.shiftwidth = [str2nr(pairs.indent_size)] + sources.indent_size
                                if &g:shiftwidth == 0 && !has_key(pairs, 'tab_width') && pairs.indent_size !=? 'tab'
                                  let options.tabstop = options.shiftwidth
                                  let options.shiftwidth = [0] + sources.indent_size
                                endif
    3              0.000002   endif
                            
    3              0.000022   if get(pairs, 'tab_width', '') =~? '^[1-9]\d*$'
                                let options.tabstop = [str2nr(pairs.tab_width)] + sources.tab_width
                                if !has_key(pairs, 'indent_size') && get(pairs, 'indent_style', '') ==? 'tab'
                                  let options.shiftwidth = [0] + options.tabstop[1:-1]
                                endif
    3              0.000002   endif
                            
    3              0.000020   if get(pairs, 'max_line_length', '') =~? '^[1-9]\d*$\|^off$'
                                let options.textwidth = [str2nr(pairs.max_line_length)] + sources.max_line_length
    3              0.000002   endif
                            
    3              0.000020   if get(pairs, 'insert_final_newline', '') =~? '^true$\|^false$'
                                let options.endofline = [pairs.insert_final_newline ==? 'true'] + sources.insert_final_newline
                                let options.fixendofline = copy(options.endofline)
    3              0.000001   endif
                            
    3              0.000015   let eol = tolower(get(pairs, 'end_of_line', ''))
    3              0.000011   if has_key(s:editorconfig_fileformat, eol)
                                let options.fileformat = [s:editorconfig_fileformat[eol]] + sources.end_of_line
    3              0.000001   endif
                            
    3              0.000010   let charset = tolower(get(pairs, 'charset', ''))
    3              0.000008   if has_key(s:editorconfig_bomb, charset)
                                let options.bomb = [s:editorconfig_bomb[charset]] + sources.charset
                                let options.fileencoding = [substitute(charset, '\C-bom$', '', '')] + sources.charset
    3              0.000001   endif
                            
    3              0.000029   let filetype = tolower(get(pairs, 'vim_filetype', 'unset'))
    3              0.000007   if filetype !=# 'unset' && filetype =~# '^[.a-z0-9_-]*$'
                                let options.filetype = [substitute(filetype, '^\.\+\|\.\+$', '', 'g')] + sources.vim_filetype
    3              0.000001   endif
                            
    3              0.000004   return options

FUNCTION  <SNR>7_Ready()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:384
Called 6 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    6              0.000030   return has_key(a:detected.options, 'expandtab') && has_key(a:detected.options, 'shiftwidth')

FUNCTION  <SNR>7_DetectEditorConfig()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:270
Called 3 times
Total time:   0.004752
 Self time:   0.004752

count  total (s)   self (s)
    3              0.000010   if empty(a:absolute_path)
                                return [{}, '']
    3              0.000002   endif
    3              0.000004   let root = ''
    3              0.000008   let tail = a:0 ? a:1 : '.editorconfig'
    3              0.000018   let dir = fnamemodify(a:absolute_path, ':h')
    3              0.000005   let previous_dir = ''
    3              0.000005   let sections = []
    3              0.000029   let overrides = get(g:, 'sleuth_editorconfig_overrides', {})
   30              0.000240   while dir !=# previous_dir && dir !~# '^//\%([^/]\+/\=\)\=$'
   27              0.000247     let head = substitute(dir, '/\=$', '/', '')
   27              0.000177     let read_from = get(overrides, head . tail, get(overrides, head, head . tail))
   27              0.000043     if read_from is# ''
                                  break
   27              0.000163     elseif type(read_from) == type('') && read_from !=# head . tail && read_from !~# '^/\|^\a\+:'
                                  let read_from = simplify(head . read_from)
   27              0.000014     endif
   27              0.001150     let ftime = type(read_from) == type('') ? getftime(read_from) : -1
   27              0.000207     let [cachetime; econfig] = get(s:editorconfig_cache, read_from, [-1, {}, []])
   27              0.000042     if ftime != cachetime
                                  let econfig = s:ReadEditorConfig(read_from)
                                  let s:editorconfig_cache[read_from] = [ftime] + econfig
                                  lockvar! s:editorconfig_cache[read_from]
                                  unlockvar s:editorconfig_cache[read_from]
   27              0.000014     endif
   27              0.000098     call extend(sections, econfig[1], 'keep')
   27              0.000116     if get(econfig[0], 'root', [''])[0] ==? 'true'
                                  let root = head
                                  break
   27              0.000015     endif
   27              0.000044     let previous_dir = dir
   27              0.000089     let dir = fnamemodify(dir, ':h')
   30              0.001472   endwhile
                            
    3              0.000007   let config = {}
    3              0.000010   for [pattern, pairs] in sections
                                if a:absolute_path =~# pattern
                                  call extend(config, pairs)
                                endif
    3              0.000004   endfor
                            
    3              0.000010   return [config, root]

FUNCTION  <SNR>7_Init()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:593
Called 3 times
Total time:   0.026144
 Self time:   0.000527

count  total (s)   self (s)
    3              0.000010   if !a:redetect && exists('b:sleuth.defaults')
                                let detected = b:sleuth
    3              0.000003   endif
    3              0.000009   unlet! b:sleuth
    3              0.000059   if &l:buftype !~# '^\%(nowrite\|nofile\|acwrite\)\=$'
                                return s:Warn(':Sleuth disabled for buftype=' . &l:buftype, a:silent)
    3              0.000002   endif
    3              0.000006   if &l:filetype ==# 'netrw'
                                return s:Warn(':Sleuth disabled for filetype=' . &l:filetype, a:silent)
    3              0.000001   endif
    3              0.000005   if &l:binary
                                return s:Warn(':Sleuth disabled for binary files', a:silent)
    3              0.000002   endif
    3              0.000011   if !exists('detected')
    3   0.006913   0.000122     let detected = s:DetectDeclared()
    3              0.000002   endif
    3              0.000005   let setfiletype = ''
    3              0.000012   if a:do_filetype && has_key(detected.declared, 'filetype')
                                let filetype = detected.declared.filetype[0]
                                if filetype !=# &l:filetype || empty(filetype)
                                  let setfiletype = 'setlocal filetype=' . filetype
                                else
                                  let setfiletype = 'setfiletype ' . filetype
                                endif
    3              0.000001   endif
    3              0.000010   exe setfiletype
    3   0.018070   0.000055   call s:DetectHeuristics(detected)
    3   0.000872   0.000061   let cmd = s:Apply(detected, (a:do_filetype ? ['filetype'] : []) + (a:unsafe ? s:all_options : s:safe_options), a:silent)
    3              0.000007   let b:sleuth = detected
    3              0.000008   if exists('s:polyglot') && !a:silent
                                call s:Warn('Charlatan :Sleuth implementation in vim-polyglot has been found and disabled.')
                                call s:Warn('To get rid of this message, uninstall vim-polyglot, or disable the')
                                call s:Warn('corresponding feature in your vimrc:')
                                call s:Warn('        let g:polyglot_disabled = ["autoindent"]')
    3              0.000001   endif
    3              0.000004   return cmd

FUNCTION  <SNR>7_Slash()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:29
Called 5 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    5              0.000034     return tr(a:path, '\', '/')

FUNCTION  <SNR>7_ModelineOptions()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:182
Called 3 times
Total time:   0.000886
 Self time:   0.000593

count  total (s)   self (s)
    3              0.000004   let options = {}
    3              0.000021   if !&l:modeline && (&g:modeline || s:Capture('setlocal') =~# '\\\@<![[:space:]]nomodeline\>' && s:Capture('verbose setglobal modeline?') !=# s:Capture('verbose setlocal modeline?'))
                                return options
    3              0.000001   endif
    3              0.000017   let modelines = get(b:, 'sleuth_modelines', get(g:, 'sleuth_modelines', 5))
    3              0.000013   if line('$') > 2 * modelines
    1              0.000010     let lnums = range(1, modelines) + range(line('$') - modelines + 1, line('$'))
    2              0.000002   else
    2              0.000009     let lnums = range(1, line('$'))
    3              0.000002   endif
   15              0.000017   for lnum in lnums
   12   0.000702   0.000410     if s:ParseOptions(split(matchstr(getline(lnum), '\%(\S\@<!vim\=\|\s\@<=ex\):\s*\(set\= \zs[^:]\+\|\zs.*\S\)'), '[[:space:]:]\+'), options, 'modeline', lnum)
                                  break
   12              0.000006     endif
   15              0.000011   endfor
    3              0.000003   return options

FUNCTION  <SNR>7_Warn()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:19
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000007   if !get(a:000, 0, 0)
                                echohl WarningMsg
                                echo a:msg
                                echohl NONE
    2              0.000001   endif
    2              0.000002   return ''

FUNCTION  <SNR>7_DetectDeclared()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:488
Called 3 times
Total time:   0.006791
 Self time:   0.000697

count  total (s)   self (s)
    3   0.000077   0.000053   let detected = {'bufname': s:Slash(@%), 'declared': {}}
    3              0.000047   let absolute_or_empty = detected.bufname =~# '^$\|^\a\+:\|^/'
    3              0.000029   if &l:buftype =~# '^\%(nowrite\)\=$' && !absolute_or_empty
                                let detected.bufname = substitute(s:Slash(getcwd()), '/\=$', '/', '') . detected.bufname
                                let absolute_or_empty = 1
    3              0.000002   endif
    3              0.000017   let detected.path = absolute_or_empty ? detected.bufname : ''
    3              0.000064   let pre = substitute(matchstr(detected.path, '^\a\a\+\ze:'), '^\a', '\u&', 'g')
    3              0.000020   if len(pre) && exists('*' . pre . 'Real')
                                let detected.path = s:Slash(call(pre . 'Real', [detected.path]))
    3              0.000002   endif
                            
    3              0.000005   try
    3              0.000024     if len(detected.path) && exists('*ExcludeBufferFromDiscovery') && !empty(ExcludeBufferFromDiscovery(detected.path, 'sleuth'))
                                  let detected.path = ''
    3              0.000002     endif
                              catch
    3              0.000005   endtry
    3   0.004804   0.000052   let [detected.editorconfig, detected.root] = s:DetectEditorConfig(detected.path)
    3   0.000598   0.000165   call extend(detected.declared, s:EditorConfigToOptions(detected.editorconfig))
    3   0.001021   0.000135   call extend(detected.declared, s:ModelineOptions())
    3              0.000003   return detected

FUNCTION  <SNR>7_UserOptions()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:460
Called 3 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    3              0.000014   if exists('b:sleuth_' . a:name)
                                let source = 'b:sleuth_' . a:name
    3              0.000016   elseif exists('g:sleuth_' . a:ft . '_' . a:name)
                                let source = 'g:sleuth_' . a:ft . '_' . a:name
    3              0.000001   endif
    3              0.000017   if !exists('l:source') || type(eval(source)) == type(function('tr'))
    3              0.000004     return {}
                              endif
                              let val = eval(source)
                              let options = {}
                              if type(val) == type('')
                                call s:ParseOptions(split(substitute(val, '\S\@<![=+]\S\@=', 'ft=', 'g'), '[[:space:]:,]\+'), options, source)
                                if has_key(options, 'filetype')
                                  call extend(options, s:UserOptions(remove(options, 'filetype')[0], a:name), 'keep')
                                endif
                                if has_key(options, 'tabstop')
                                  call extend(options, {'shiftwidth': [0, source], 'expandtab': [0, source]}, 'keep')
                                elseif has_key(options, 'shiftwidth')
                                  call extend(options, {'expandtab': [1, source]}, 'keep')
                                endif
                              elseif type(val) == type([])
                                call s:ParseOptions(val, options, source)
                              endif
                              call filter(options, 'index(s:safe_options, v:key) >= 0')
                              return options

FUNCTION  <SNR>17_Highlight_Matching_Pair()
    Defined: ~\AppData\Local\Programs\nvim\share/nvim/runtime/plugin/matchparen.vim:45
Called 90 times
Total time:   0.017328
 Self time:   0.015076

count  total (s)   self (s)
   90              0.001039   if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
   90              0.000139   endif
                              " Remove any previous match.
   90   0.003539   0.001286   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   90              0.000901   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   90              0.000055   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   90              0.000464   let c_lnum = line('.')
   90              0.000320   let c_col = col('.')
   90              0.000142   let before = 0
                            
   90              0.000498   let text = getline(c_lnum)
   90              0.000806   let c_before = text->strpart(0, c_col - 1)->slice(-1)
   90              0.000477   let c = text->strpart(c_col - 1)->slice(0, 1)
   90              0.002527   let plist = split(&matchpairs, '.\zs[:,]')
   90              0.000447   let i = index(plist, c)
   90              0.000149   if i < 0
                                " not found, in Insert mode try character before the cursor
   84              0.000510     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   57              0.000247       let before = strlen(c_before)
   57              0.000103       let c = c_before
   57              0.000176       let i = index(plist, c)
   84              0.000078     endif
   84              0.000104     if i < 0
                                  " not found, nothing to do
   84              0.000109       return
                                endif
    6              0.000003   endif
                            
                              " Figure out the arguments for searchpairpos().
    6              0.000008   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    6              0.000005   else
    6              0.000009     let s_flags = 'nbW'
    6              0.000009     let c2 = c
    6              0.000016     let c = plist[i - 1]
    6              0.000003   endif
    6              0.000009   if c == '['
                                let c = '\['
                                let c2 = '\]'
    6              0.000003   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    6              0.000007   if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
    6              0.000003   endif
                            
    6              0.000054   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    6              0.000029   elseif exists("b:ts_highlight") && &syntax != 'on'
    6              0.000028     let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 && synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
    6              0.000019   endif
                            
                              " Limit the search to lines visible in the window.
    6              0.000020   let stoplinebottom = line('w$')
    6              0.000013   let stoplinetop = line('w0')
    6              0.000007   if i % 2 == 0
                                let stopline = stoplinebottom
    6              0.000003   else
    6              0.000011     let stopline = stoplinetop
    6              0.000003   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    6              0.000021   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    6              0.000003   else
    6              0.000036     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    6              0.000003   endif
    6              0.000005   try
    6              0.001109     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    6              0.000006   endtry
                            
                              " If a match is found setup match highlighting.
    6              0.000021   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
    6              0.000011     if !g:matchparen_disable_cursor_hl
    6              0.000076       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
    6              0.000003     endif
    6              0.000011     let w:paren_hl_on = 1
    6              0.000003   endif

FUNCTION  nvim_treesitter#indent()
    Defined: ~\AppData\Local\nvim-data\lazy\nvim-treesitter\autoload\nvim_treesitter.vim:25
Called 3 times
Total time:   0.018170
 Self time:   0.018170

count  total (s)   self (s)
    3              0.018152 	return luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))

FUNCTION  <SNR>2_LoadIndent()
    Defined: ~\AppData\Local\Programs\nvim\share\nvim\runtime\indent.vim:14
Called 9 times
Total time:   0.018580
 Self time:   0.018392

count  total (s)   self (s)
    9              0.000073     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    9              0.000008     endif
    9              0.000085     let s = expand("<amatch>")
    9              0.000027     if s != ""
    9              0.000025       if exists("b:did_indent")
                            	unlet b:did_indent
    9              0.000006       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   18              0.000190       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    9   0.017933   0.017745         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   18              0.000041       endfor
    9              0.000010     endif

FUNCTION  <SNR>7_ParseOptions()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:166
Called 12 times
Total time:   0.000293
 Self time:   0.000293

count  total (s)   self (s)
   12              0.000022   for option in a:declarations
                                if has_key(s:modeline_booleans, matchstr(option, '^\%(no\)\=\zs\w\+$'))
                                  let a:into[s:modeline_booleans[matchstr(option, '^\%(no\)\=\zs\w\+')]] = [option !~# '^no'] + a:000
                                elseif has_key(s:modeline_numbers, matchstr(option, '^\w\+\ze=[1-9]\d*$'))
                                  let a:into[s:modeline_numbers[matchstr(option, '^\w\+')]] = [str2nr(matchstr(option, '\d\+$'))] + a:000
                                elseif option =~# '^\%(ft\|filetype\)=[[:alnum:]._-]*$'
                                  let a:into.filetype = [matchstr(option, '=\zs.*')] + a:000
                                endif
                                if option ==# 'nomodeline' || option ==# 'noml'
                                  return 1
                                endif
   12              0.000013   endfor
   12              0.000009   return 0

FUNCTION  <SNR>7_Apply()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:396
Called 3 times
Total time:   0.000811
 Self time:   0.000792

count  total (s)   self (s)
    3              0.000116   let options = extend(copy(a:detected.defaults), a:detected.options)
    3              0.000025   if get(a:detected.defaults, 'shiftwidth', [1])[0] == 0 && get(options, 'shiftwidth', [0])[0] != 0 && !has_key(a:detected.declared, 'tabstop')
                                let options.tabstop = options.shiftwidth
                                let options.shiftwidth = a:detected.defaults.shiftwidth
    3              0.000002   endif
    3              0.000011   if has_key(options, 'shiftwidth') && !has_key(options, 'expandtab')
                                let options.expandtab = [stridx(join(getline(1, 256), "\n"), "\t") == -1, a:detected.bufname]
    3              0.000002   endif
    3              0.000017   if !exists('*shiftwidth') && !get(options, 'shiftwidth', [1])[0]
                                let options.shiftwidth = [get(options, 'tabstop', [&tabstop])[0]] + options.shiftwidth[1:-1]
    3              0.000001   endif
    3              0.000004   let msg = ''
    3              0.000004   let cmd = 'setlocal'
   33              0.000038   for option in a:permitted_options
   30              0.000170     if !exists('&' . option) || !has_key(options, option) || !&l:modifiable && index(s:safe_options, option) == -1
   28              0.000017       continue
    2              0.000001     endif
    2              0.000006     let value = options[option]
    2              0.000005     if has_key(s:booleans, option)
    1              0.000004       let setting = (value[0] ? '' : 'no') . option
    1              0.000001     else
    1              0.000003       let setting = option . '=' . value[0]
    2              0.000001     endif
    2              0.000015     if getbufvar('', '&' . option) !=# value[0] || index(s:safe_options, option) >= 0
    2              0.000006       let cmd .= ' ' . setting
    2              0.000001     endif
    2              0.000003     if !&verbose || a:silent
    2              0.000004       if has_key(s:booleans, option)
    1              0.000006         let msg .= ' ' . (value[0] ? '' : 'no') . get(s:short_options, option, option)
    1              0.000001       else
    1              0.000005         let msg .= ' ' . get(s:short_options, option, option) . '=' . value[0]
    2              0.000002       endif
    2              0.000001       continue
                                endif
                                if len(value) > 1
                                  if value[1] ==# a:detected.bufname
                                    let file = '%'
                                  else
                                    let file = value[1] =~# '/' ? fnamemodify(value[1], ':~:.') : value[1]
                                    if file !=# value[1] && file[0:0] !=# '~'
                                      let file = './' . file
                                    endif
                                  endif
                                  if len(value) > 2
                                    let file .= ' line ' . value[2]
                                  endif
                                  echo printf(':setlocal %-21s " from %s', setting, file)
                                else
                                  echo ':setlocal ' . setting
                                endif
    3              0.000008   endfor
    3              0.000011   if !&verbose && !empty(msg) && !a:silent
                                echo ':setlocal' . msg
    3              0.000002   endif
    3              0.000006   if has_key(options, 'shiftwidth')
    1              0.000006     let cmd .= ' softtabstop=' . (exists('*shiftwidth') ? -1 : options.shiftwidth[0])
    2              0.000002   else
    2   0.000038   0.000020     call s:Warn(':Sleuth failed to detect indent settings', a:silent)
    3              0.000002   endif
    3              0.000008   return cmd ==# 'setlocal' ? '' : cmd

FUNCTION  <SNR>7_AutoInit()
    Defined: ~/AppData/Local/nvim-data/lazy/vim-sleuth/plugin/sleuth.vim:632
Called 3 times
Total time:   0.026190
 Self time:   0.000045

count  total (s)   self (s)
    3   0.026184   0.000040   return s:Init(1, 1, 1, 1)

FUNCTION  <SNR>29_SynSet()
    Defined: ~\AppData\Local\Programs\nvim\share\nvim\runtime\syntax\synload.vim:27
Called 12 times
Total time:   0.048728
 Self time:   0.047830

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   12              0.000099   syn clear
   12              0.000071   if exists("b:current_syntax")
                                unlet b:current_syntax
   12              0.000014   endif
                            
   12              0.000097   0verbose let s = expand("<amatch>")
   12              0.000037   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   12              0.000026   elseif s == "OFF"
                                let s = ""
   12              0.000008   endif
                            
   12              0.000019   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   20              0.000154     for name in split(s, '\.')
   10              0.000034       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   10   0.047652   0.046754         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
   10              0.000034       endif
   20              0.000031     endfor
   12              0.000012   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    9   0.092696   0.070702  <SNR>1_LoadFTPlugin()
   12   0.048728   0.047830  <SNR>29_SynSet()
    2   0.038693   0.000152  provider#clipboard#Call()
    2   0.038541             3()
    3   0.026190   0.000045  <SNR>7_AutoInit()
    3   0.026144   0.000527  <SNR>7_Init()
    9   0.018580   0.018392  <SNR>2_LoadIndent()
    3   0.018170             nvim_treesitter#indent()
    3   0.018015   0.001106  <SNR>7_DetectHeuristics()
   90   0.017328   0.015076  <SNR>17_Highlight_Matching_Pair()
    3   0.016789             <SNR>7_Guess()
    3   0.006791   0.000697  <SNR>7_DetectDeclared()
    3   0.004752             <SNR>7_DetectEditorConfig()
   93   0.002464             <SNR>17_Remove_Matches()
    3   0.000886   0.000593  <SNR>7_ModelineOptions()
    3   0.000811   0.000792  <SNR>7_Apply()
    3   0.000432             <SNR>7_EditorConfigToOptions()
   12   0.000293             <SNR>7_ParseOptions()
    2   0.000187             1()
    3   0.000068             <SNR>7_UserOptions()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    9   0.092696   0.070702  <SNR>1_LoadFTPlugin()
   12   0.048728   0.047830  <SNR>29_SynSet()
    2              0.038541  3()
    9   0.018580   0.018392  <SNR>2_LoadIndent()
    3              0.018170  nvim_treesitter#indent()
    3              0.016789  <SNR>7_Guess()
   90   0.017328   0.015076  <SNR>17_Highlight_Matching_Pair()
    3              0.004752  <SNR>7_DetectEditorConfig()
   93              0.002464  <SNR>17_Remove_Matches()
    3   0.018015   0.001106  <SNR>7_DetectHeuristics()
    3   0.000811   0.000792  <SNR>7_Apply()
    3   0.006791   0.000697  <SNR>7_DetectDeclared()
    3   0.000886   0.000593  <SNR>7_ModelineOptions()
    3   0.026144   0.000527  <SNR>7_Init()
    3              0.000432  <SNR>7_EditorConfigToOptions()
   12              0.000293  <SNR>7_ParseOptions()
    2              0.000187  1()
    2   0.038693   0.000152  provider#clipboard#Call()
    3              0.000068  <SNR>7_UserOptions()
    3   0.026190   0.000045  <SNR>7_AutoInit()

